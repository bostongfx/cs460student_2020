<html>
<head>
<title>CS460 project</title>
    
    <meta content="utf-8" http-equiv="encoding">
    <style>
    html, body {
        
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;
        background-image: url(keuhGH.jpeg);
         background-repeat: no-repeat;
        background-size: 100% 100%;
       
                
        }
        a{
            text-align: center;
            font-size: 10px;
            color: white;
            
        }
        p{
             color: white;
            text-align: center;
             font-size: 20px;
           
        }
    
      
        
    
    </style>
     <p> Click on each circular geomerty to listen.</p>
 <!-- <a href="https://shruti1610.github.io/portfolio/">Link to my Portfolio</a>-->
   
   
    <script src="https://threejs.org/build/three.min.js" type="text/javascript"></script>
    <script src="https://threejs.org/examples/js/controls/TrackballControls.js" type="text/javascript"></script>
    <script src="threex.js"></script>
   <script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://threejs.org/examples/js/effects/AnaglyphEffect.js" type="text/javascript"></script>
    <script src="avatar.js"></script>
    <script src="helper.js"></script>
   
		
		<script src='https://cdn.jsdelivr.net/gh/mrdoob/Three.js@r92/examples/js/loaders/GLTFLoader.js'></script>
    <script typr="text/javascript"> 
      
   
        window.onload=function()
        {
            
          //------
           var animationM;
            let clock = new THREE.Clock();
           var scene = new THREE.Scene();
            let raycaster = new THREE.Raycaster();
            let currentlyAnimating = false;
            let neck; 
  let waist;
            var model;
            let i;
            let possibleAnims;
          var fov = 75;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 1;
        var zFar = 10000;
            var textureLoader = new THREE.TextureLoader();
        camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
        camera.position.set( 0, 0, 100);

        var renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
            
           
        
            ambientLight = new THREE.AmbientLight( 0x404040 );
            scene.add( ambientLight );

             
            
            light = new THREE.DirectionalLight( 0xffffff, 4.0 );
            light.position.set( 10, 100, 10  );
            scene.add( light );
            
            light = new THREE.DirectionalLight( 0xffffff, 1.0 );
            light.position.set( 10, 10, -100 );
            scene.add( light );
            
           /* var light2 = new THREE.PointLight( 0xffffff, 2.0 );
          light2.position.set( 0, -10, 10 );
          scene.add( light2);*/
            
            
            const loader = new THREE.TextureLoader();
var bgTexture = loader.load('keuhGH.jpeg');
scene.background = bgTexture;
            
            const geometry = new THREE.CircleGeometry( 20, 32 );
            const texture = new THREE.TextureLoader().load('20-512.png');
const material = new THREE.MeshStandardMaterial( { map: texture,
                                              side: THREE.DoubleSide,
                                              skinning: true} );
        
const circle = new THREE.Mesh( geometry, material );
        circle.position.set(-70,40,0);
scene.add( circle );
            
            const geometry1 = new THREE.CircleGeometry( 20, 32 );
            const texture1 = new THREE.TextureLoader().load('234588.png');
const material1 = new THREE.MeshStandardMaterial( { map: texture1,
                                              side: THREE.DoubleSide,
                                              skinning: true} );
        
const circle1 = new THREE.Mesh( geometry1, material1 );
        circle1.position.set(-35,30,0);
scene.add( circle1 );
            
            const geometry2 = new THREE.CircleGeometry( 20, 32 );
            const texture2 = new THREE.TextureLoader().load('exp.png');
const material2 = new THREE.MeshStandardMaterial( { map: texture2,
                                              side: THREE.DoubleSide,
                                              skinning: true} );
        
const circle2 = new THREE.Mesh( geometry2, material2 );
        circle2.position.set(0,40,0);
scene.add( circle2 );
            
            const geometry3 = new THREE.CircleGeometry( 20, 32 );
            const texture3 = new THREE.TextureLoader().load('proj.png');
const material3 = new THREE.MeshStandardMaterial( { map: texture3,
                                              side: THREE.DoubleSide,
                                              skinning: true} );
        
const circle3 = new THREE.Mesh( geometry3, material3 );
        circle3.position.set(35,30,0);
scene.add( circle3 );
            
            const geometry4 = new THREE.CircleGeometry( 20, 32 );
            const texture4 = new THREE.TextureLoader().load('con.png');
const material4 = new THREE.MeshStandardMaterial( { map: texture4,
                                              side: THREE.DoubleSide,
                                              skinning: true} );
        
const circle4 = new THREE.Mesh( geometry4, material4 );
        circle4.position.set(70,40,0);
scene.add( circle4 );
            
     /* r = new Robot(50,0,0);
          r.name='Robot1';
          r.show(scene);  */    
            
            
const loader1 = new THREE.GLTFLoader();
const textureface = new THREE.TextureLoader().load( 'texture.png' );
            const texturebody = new THREE.TextureLoader().load( 'shruti.png' );


const materialface = new THREE.MeshPhongMaterial( { map: textureface } );
  // renderer.outputEncoding = THREE.sRGBEncoding;
//textureface.encoding = THREE.sRGBEncoding;

// UVs use the convention that (0, 0) corresponds to the upper left corner of a texture.
textureface.flipY = false;
 texturebody.flipY = false;           

// Load a glTF resource
             const stacy_mtl = new THREE.MeshStandardMaterial({
      map: textureface,
      color: 0xffffff,
      skinning: true });
            
            const stacy = new THREE.MeshStandardMaterial({
      map: texturebody,
      color: 0xffffff,
      skinning: true });

loader1.load(
	// resource URL
	'notexture.glb',
	// called when the resource is loaded
	function ( gltf ) {
      // gltf.scene.position.set(50,-20,-3);
 model = gltf.scene;
        
        model.traverse(o => {

        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
         // o.material = stacy_mtl;
        }
        // Reference the neck and waist bones
      });

      model.scale.set(15, 15, 15);
      model.position.set(90,-27,0);

      scene.add(model);
        
          

	},
	// called while loading is progressing
	function ( xhr ) {

		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

	},
	// called when loading has errors
	function ( error ) {

		console.log( 'An error happened' );

	}
);
            const loader2 = new THREE.GLTFLoader();
            loader2.load(
	// resource URL
	'stacy_lightweight.glb',
	// called when the resource is loaded
	function ( gltf ) {
     //  gltf.scene.position.set(-50,-50,-5);
// var mesh = gltf.scene;
        let fileAnimations = gltf.animations;
        var model1 = gltf.scene;
        
        model1.traverse(o => {

        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
          o.material = stacy;
        }
      
            if (o.isBone && o.name === 'mixamorigNeck') {
          neck = o;
        }
        if (o.isBone && o.name === 'mixamorigSpine') {
          waist = o;
        }
      });

      model1.scale.set(45, 45, 45);
      model1.position.set(0,-70,-5);

      scene.add(model1);
        
        
        

    

	},
	// called while loading is progressing
	function ( xhr ) {

		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

	},
	// called when loading has errors
	function ( error ) {

		console.log( 'An error happened' );

	}
);
            
            function update() {
    if (animationM) {
      animationM.update(clock.getDelta());
    }

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(update);
  }

  update();

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    let width = window.innerWidth;
    let height = window.innerHeight;
    let canvasPixelWidth = canvas.width / window.devicePixelRatio;
    let canvasPixelHeight = canvas.height / window.devicePixelRatio;

    const needResize =
    canvasPixelWidth !== width || canvasPixelHeight !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

          

 
 
  document.addEventListener('mousemove', function (e) {
    var mousecoords = getMousePos(e);
    if (neck && waist) {

      moveJoint(mousecoords, neck, 50);
      moveJoint(mousecoords, waist, 30);
    }
  });

  function getMousePos(e) {
    return { x: e.clientX, y: e.clientY };
  }

  function moveJoint(mouse, joint, degreeLimit) {
    let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
    joint.rotation.y = THREE.Math.degToRad(degrees.x);
    joint.rotation.x = THREE.Math.degToRad(degrees.y);
    console.log(joint.rotation.x);
  }

  function getMouseDegrees(x, y, degreeLimit) {
    let dx = 0,
    dy = 0,
    xdiff,
    xPercentage,
    ydiff,
    yPercentage;

    let w = { x: window.innerWidth, y: window.innerHeight };

   
    if (x <= w.x / 2) {
     
      xdiff = w.x / 2 - x;
     
      xPercentage = xdiff / (w.x / 2) * 100;
    
      dx = degreeLimit * xPercentage / 100 * -1;
    }

   
    if (x >= w.x / 2) {
      xdiff = x - w.x / 2;
      xPercentage = xdiff / (w.x / 2) * 100;
      dx = degreeLimit * xPercentage / 100;
    }
   
    if (y <= w.y / 2) {
      ydiff = w.y / 2 - y;
      yPercentage = ydiff / (w.y / 2) * 100;
      
      dy = degreeLimit * 0.5 * yPercentage / 100 * -1;
    }
   
    if (y >= w.y / 2) {
      ydiff = y - w.y / 2;
      yPercentage = ydiff / (w.y / 2) * 100;
      dy = degreeLimit * yPercentage / 100;
    }
    return { x: dx, y: dy };
  }
      
           const listener1 = new THREE.AudioListener();
camera.add( listener1 );

// create a global audio source
const sound1 = new THREE.Audio( listener1 );

// load a sound and set it as the Audio object's buffer
const audioLoader1 = new THREE.AudioLoader();
audioLoader1.load( 'music.mp3', function( buffer ) {
	sound1.setBuffer( buffer );
	sound1.setLoop( true );
	sound1.setVolume( 0.3 );
	sound1.play();
                
            });
            
            const texturec = new THREE.TextureLoader().load( 'boardx.png' );

				const geometryc = new THREE.BoxBufferGeometry( 50, 20, 20 );
				const materialc = new THREE.MeshBasicMaterial( { map: texturec } );

				cube = new THREE.Mesh( geometryc, materialc );
            cube.position.set(90,-50,0)
				scene.add( cube );

            
            
           controls = new THREE.TrackballControls( camera, renderer.domElement );
            
         renderer.domElement.onclick = function(e) { //From assignment 3

            
          console.log('yes! you clicked!');

          pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

          console.log('Pixel coordinates', pixel_coords);

          vp_coords = new THREE.Vector2( ( pixel_coords.x / window.innerWidth ) * 2 - 1,
                                        -( pixel_coords.y / window.innerHeight ) * 2 + 1);

          console.log('Viewport coordinates', vp_coords);

          vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

          var raycaster1 = new THREE.Raycaster();
          raycaster1.setFromCamera(vp_coords_near, camera);
             
            
             
          var intersect = raycaster1.intersectObject(circle);
             var intersect1 = raycaster1.intersectObject(circle1);
             var intersect2 = raycaster1.intersectObject(circle2);
             var intersect3 = raycaster1.intersectObject(circle3);
             var intersect4 = raycaster1.intersectObject(circle4);
             
            
                 if (intersect[0]) {console.log('circle');
                                    
                                   const listener = new THREE.AudioListener();
camera.add( listener );

// create a global audio source
const sound = new THREE.Audio( listener );

// load a sound and set it as the Audio object's buffer
const audioLoader = new THREE.AudioLoader();
audioLoader.load( 'pro.m4a', function( buffer ) {
	sound.setBuffer( buffer );
	sound.setLoop( false );
	sound.setVolume( 0.4 );
	sound.play();
                
            });} 
             if (intersect1[0]) {console.log('circle1');
                                const listener2 = new THREE.AudioListener();
camera.add( listener2 );

// create a global audio source
const sound2 = new THREE.Audio( listener2 );

// load a sound and set it as the Audio object's buffer
const audioLoader2 = new THREE.AudioLoader();
audioLoader2.load( 'edu.m4a', function( buffer ) {
	sound2.setBuffer( buffer );
	sound2.setLoop( false );
	sound2.setVolume( 0.4 );
	sound2.play();
                
            });} 
             if (intersect2[0]) {console.log('circle2');
                                const listener3 = new THREE.AudioListener();
camera.add( listener3 );

// create a global audio source
const sound3 = new THREE.Audio( listener3 );

// load a sound and set it as the Audio object's buffer
const audioLoader3 = new THREE.AudioLoader();
audioLoader3.load( 'exp.m4a', function( buffer ) {
	sound3.setBuffer( buffer );
	sound3.setLoop( false );
	sound3.setVolume( 0.4 );
	sound3.play();
                
            });} 
             if (intersect3[0]) {console.log('circle3');
                                const listener4 = new THREE.AudioListener();
camera.add( listener4 );

// create a global audio source
const sound4 = new THREE.Audio( listener4 );

// load a sound and set it as the Audio object's buffer
const audioLoader4 = new THREE.AudioLoader();
audioLoader4.load( 'proj.m4a', function( buffer ) {
	sound4.setBuffer( buffer );
	sound4.setLoop( false );
	sound4.setVolume( 0.4 );
	sound4.play();
                
            });} 
             if (intersect4[0]) {console.log('circle4');
                                const listener5 = new THREE.AudioListener();
camera.add( listener5 );

// create a global audio source
const sound5 = new THREE.Audio( listener5 );

// load a sound and set it as the Audio object's buffer
const audioLoader5 = new THREE.AudioLoader();
audioLoader5.load( 'con.m4a', function( buffer ) {
	sound5.setBuffer( buffer );
	sound5.setLoop( false );
	sound5.setVolume( 0.5 );
	sound5.play();
                
            });} 
         
        }
          
            
          
            animate();
    
    
         function animate() {

        requestAnimationFrame( animate );

             //circle.rotation.x += 0.01;
  circle.rotation.y += 0.01;
            // circle1.rotation.x += 0.01;
  circle1.rotation.y += 0.01;
             //circle2.rotation.x += 0.01;
  circle2.rotation.y += 0.01;
             //circle3.rotation.x += 0.01;
  circle3.rotation.y += 0.01;
             //circle4.rotation.x += 0.01;
  circle4.rotation.y += 0.01;
             
             if ( model ) model.rotation.y -= 0.005;
        controls.update();
        renderer.render( scene, camera );

      };
           
           
        }
    </script>
</head>
<body></body>
</html>